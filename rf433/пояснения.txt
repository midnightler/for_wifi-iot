Параметры:
Опция:
RCswitch передатчик 433/315

Bits по умолчанию : 24

per по умолчанию  192

Количество Remap GPIO (можно больше 10-и)

№№№№№№№№№
Конструктор кода:
период таймера задаём 200мс.
пример для ESP32:
ets_timer_arm(&esp_timer_name, 200, 1);// от 200мс, 1-постоянная работа 
	
пояснения:
параметр per=192 - который задает время импульсов в миллисекундах
это время одной "пачки" импульсов
эти "пачки" состоят из "посылок" кода передатчика
в каждой "пачке" по 8 штук "посылок"
для длительной отправки кода (постоянного включения реле на некоторое время)
нужно отправлять энное количество таких пачек последовательно и непрерывно
время между пачками: оптимально - 8мс, пределы 7-10мс
если меньше модуль ребутится
если больше 10мс приёмник успевает отключиться (щёлкает реле)
пояснение по работе приёмника (почему щёлкает):
Все готовые китайские приёмники работают по принципу:
принимает посылки кода,
сравнивает каждую последующую с двумя предыдущими,
если все три одинаковые - включает выход,
если посылки теряются и нет трёх одинаковых подряд
выход отключается.
Получается если время повтора более 10мс посылка теряется,
Следующее срабатывание приёмника через 200+200+200мс,
отсюда и щелчки реле.

per=192 для удобства 
192мс+8мс=200мс
200мс*5=1сек.

****************************

static timer_t esp_timer_name; // глобально объявим таймер esp_timer_name
// можно обзвать посвоему
void read_kod() { // код, который будет вызываться по таймеру каждые 200мс
// здесь функции отправки кода
	}
			
void startfunc() {
	ets_timer_disarm(&esp_timer_name);
	ets_timer_setfn(&esp_timer_name, read_kod, NULL);  // read_kod -функция, которую нужно вызвать по таймеру.
	ets_timer_arm(&esp_timer_name, 200, 1);//запуск, 200мс, 1-постоянная работа
}

void timerfunc(uint32_t timersrc) { //можно писать другой код,
// можно оставить пустым, и весь код обрабатываеть в esp_timer_name
vTaskDelay(1000 / portTICK_PERIOD_MS);
    }

void webfunc(char *pbuf) { //тут html код
os_sprintf(HTTPBUFF,"бла-бла-бла ");
}





